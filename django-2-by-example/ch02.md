**Chapter 2 Enhancing Your Blog with Advanced Features**

In this chapter, you will learn the following topics:
- Sending emails with Django
- Creating forms and handling them in views
- Creating forms from models
- Integrating third-party applications
- Building complex QuerySets

# Sharing posts by email
You will need to do the following things:
- Create a form for users to fill in their name and email, the email recipient, and optional comments
- Create a view in the `views.py` file that handles the posted data and sends the email
- Add a URL pattern for the new view in the `urls.py` file of the blog application
- Create a template to display the form

## Creating forms with Django
Django comes with two base classes to build forms:
- `Form`: Allows you to build standard forms
- `ModelForm`: Allows you to build forms tied to model instances

`blog/forms.py`:
```py
from django import forms


class EmailPostForm(forms.Form):
    name = forms.CharField(max_length=255)
    email = forms.EmailField()
    to = forms.EmailField()
    comments = forms.CharField(required=False, widget=forms.Textarea)
```

## Handling forms in views
Edit the `blog/views.py` file of your `blog` application and add the following code to it:
```py
from .forms import EmailPostForm

def post_share(request, post_id):
    # Retrieve post by id
    post = get_object_or_404(Post, id=post_id, status='published')

    if request.method == 'POST':
        # Form was submitted
        form = EmailPostForm(request.POST)
        if form.is_valid():
            # Form fields passed validation
            cd = form.cleaned_data
            # ... send email
    else:
        form = EmailPostForm()
    return render(request, 'blog/post/share.html', {
        'post': post,
        'form': form
    })
```
## Sending emails with Django
`settings.py`:
- `EMAIL_HOST`: The SMTP server host; the default is `localhost`
- `EMAIL_PORT`: The SMTP port; the default is `25`
- `EMAIL_HOST_USER`: Username for the SMTP server
- `EMAIL_HOST_PASSWORD`: Password for the SMTP server
- `EMAIL_USE_TLS`: Whether to use a TLS secure connection
- `EMAIL_USE_SSL`: Whether to use an implicit TLS secure connection

If you cannot use an SMTP server, you can tell Django to write emails to the console by adding the following setting to the `settings.py` file:
```py
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
```
emails via Gmail servers using a *Google* account:
```py
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_HOST_USER = 'your_account@gmail.com'
EMAIL_HOST_PASSWORD = 'your_password'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
```

OR using a *www.163.com* account:
```
EMAIL_HOST = 'smtp.163.com'
EMAIL_HOST_USER = 'keer2345@163.com'
EMAIL_HOST_PASSWORD = '******'  # your Password or Authorization code
EMAIL_PORT = 25
EMAIL_USE_TLS = True
```
```
python manage.py shell
>>> from django.core.mail import send_mail
>>> send_mail('Django mail', 'This e-mail was sent with Django.',
'keer2345@163', ['send_mail@gmail.com'], fail_silently=False)
```

Now, we will add this functionality to our view.

Edit the `post_share` view in the `views.py` file of the `blog` application as follows:
```py
from django.core.mail import send_mail

# ...

def post_share(request, post_id):
    # Retrieve post by id
    post = get_object_or_404(Post, id=post_id, status='published')
    sent = False 
 
    if request.method == 'POST':
        # Form was submitted
        form = EmailPostForm(request.POST)
        if form.is_valid():
            # Form fields passed validation
            cd = form.cleaned_data
            post_url = request.build_absolute_uri(
                                          post.get_absolute_url())
            subject = '{} ({}) recommends you reading "{}"'.format(cd['name'], cd['email'], post.title)
            message = 'Read "{}" at {}\n\n{}\'s comments: {}'.format(post.title, post_url, cd['name'], cd['comments'])
            send_mail(subject, message, 'admin@myblog.com',
 [cd['to']])
            sent = True
    else:
        form = EmailPostForm()
    return render(request, 'blog/post/share.html', {'post': post,
                                                    'form': form,
                                                    'sent': sent})
```

`blog/urls.py`:
```py
urlpatterns = [
    
    # ...

    path('<int:post_id>/share/', views.post_share, name='post_share'),
]
```

## Rendering forms in templates
Create a new file in the `blog/templates/blog/post/` directory and name it `share.html`:
```html
{% extends "blog/base.html" %}
{% block title %}Share a post{% endblock %}
{% block content %}

    {% if sent %}
        <h1>E-mail successfully sent</h1>
        <p>
            "{{post.title}}" was successfully sent to {{form.cleaned_data.to}}.
        </p>
    {% else %}
        <h1>Share "{{post.title}}" by e-mail:</h1>
        <form action="." method="POST">
            {{ form.as_p }}
            {% csrf_token %}
            <input type="submit" value="Send email">
        </form>
    {% endif %}

{% endblock %}
```

We canalso iterate through the fields, as in the following example:
```html
{% for field in form %}
    <div>
        {{ field.errors }}
        {{ field.label_tag }} {{ field }}
    </div>
{% endfor %}
```

Edit your `blog/post/detail.html` template and add the following link to the share post URL after the `{{ post.body|linebreaks }}` variable:
```html
    <p>
        <a href="{% url "blog:post_share" post.id %}">
            Share this post
        </a>
    </p>
```
