**Chapter 3 Extending Your Blog Application**

This chapter will cover the following points:
- Creating custom template tags and filters
- Adding a sitemap and post feed
- Implementing full text search with PostgreSQL

# Creating custom template tags and filters
Django offers a variety of built-in template tags, such as `{% if %}` or `{% block %}` . You have used several in your templates. You can find a complete reference of built-in template tags and filters at *https://docs.djangoproject.com/en/2.0/ref/templates/builtins/*.

However, Django also allows you to create your own template tags to perform custom actions. Custom template tags come in very handy when you need to add a functionality to your templates that is not covered by the core set of Django template tags.

## Creating custom template tags
Django provides the following helper functions that allow you to create your own template tags in an easy manner:
- `simple_tag`: Processes the data and returns a string
- `inclusion_tag`: Processes the data and returns a rendered template

```
(.venv) qinjh@arch ~/w/p/d/d/d/mysite> tree blog/templatetags
blog/templatetags
├── blog_tags.py
└── __init__.py

0 directories, 2 files
```


`blog/templatetags/blog_tags.py`:
```py
from django import template

from ..models import Post

register = template.Library()


@register.simple_tag
def total_posts():
    return Post.published.count()
```

- Each template tags module needs to contain a variable called `register` to be a valid tag library. This variable is an instance of `template.Library`, and it's used to register our own template tags and filters.
- We define a tag called `total_posts` with a Python function and use the `@register.simple_tag` decorator to register the function as a simple tag.
- Django will use the function's name as the tag name. If you want to register it using a different name, you can do it by specifying a `name` attribute, such as `@register.simple_tag(name='my_tag')`.

> After adding a new template tags module, you will need to restart the Django development server in order to use the new tags and filters in templates.

`blog/templates/blog/base.html`:
```html
{% load blog_tags %}
{% load static %}
<!DOCTYPE html>
<html>

    <!-- ... -->

  <body>

    <!-- ... -->

    <div id="sidebar">
      <h2>My Blog</h2>
      <p>This is my blog. I have written {% total_posts %} posts so far.</p>
    </div>
  </body>
</html>
```

Now, we will create another tag to display the latest posts in the sidebar of our blog. This time, we will use an inclusion tag. Using an inclusion tag, you can render a template with context variables returned by your template tag. Edit the `blog_tags.py` file and add the following code:
```py
@register.inclusion_tag('blog/post/latest_posts.html')
def show_latest_posts(count=5):
    latest_posts = Post.published.order_by('-publish')[:count]
    return {'latest_posts': latest_posts}
```

`blog/templates/blog/post/latest_posts.html`:
```html
<ul>
    {% for post in latest_posts %}
        <li>
            <a href="{{ post.get_absolute_url }}">{{ post.title }}</a>
        </li>
    {% endfor %}
</ul>
```


`blog/templates/blog/base.html`:
```html
    <!-- ... -->

    <div id="sidebar">
      <h2>My Blog</h2>
      <p>This is my blog. I have written {% total_posts %} posts so far.</p>
      
      <h3>Latest posts</h3>
      {% show_latest_posts 3 %}
    </div>

    <!-- ... -->
```

Finally, we will create a simple template tag that stores the result in a variable that can be reused rather than directly outputting it. We will create a tag to display the most commented posts. Edit the `blog_tags.py` file and add the following import and template tag in it:
```py
from django.db.models import Count

@register.simple_tag
def get_most_commented_posts(count=5):
    return Post.published.annotate(
        total_comments=Count('comments')).order_by('-total_comments')[:count]
```

`blog/templates/blog/base.html`:
```html
      <!-- ... -->
      <h3>Latest posts</h3>
      {% show_latest_posts 3 %}

      <h3>Most commented posts</h3>
      {% get_most_commented_posts 3 as most_commented_posts %}
      <ul>
        {% for post in most_commented_posts %}
          <li>
            <a href="{{ post.get_absolute_url }}">{{ post.title }}</a>
          </li>
        {% endfor %}
      </ul>

      <!-- ... -->
```

## Creating custom template filters
A filter looks like `{{ variable|my_filter }}` . Filters with an argument look like `{{ variable|my_filter:"foo" }}` . You can apply as many filters as you like to a variable, for example, `{{ variable|filter1|filter2 }}` , and each of them will be applied to the output generated by the preceding filter.

We will create a custom filter to be able to use markdown syntax in our blog posts and then convert the post contents to HTML in the templates. Markdown is a plain text formatting syntax that is very simple to use, and it's intended to be converted into HTML. You can learn the basics of this format at *https://daringfireball.net/projects/markdown/basics*.

First, install the Python markdown module via `pip` using the following command:
```
pip install Markdown
```

`blog/templatetags/blog_tags.py`:
```py
import markdown
from django.utils.safestring import mark_safe

# ...

@register.filter(name='markdownn')
def markdown_format(text):
    return mark_safe(markdown.markdown(text))
```

Now, load your template tags module in the post list and detail templates. Add the following line at the top of the `blog/post/list.html` and `blog/post/detail.html` templates after the `{% extends %}` tag:

```
{% load blog_tags %}
```

In the `post/detail.html` templates, take a look at the following line:
```
{{ post.body|linebreaks }}
```
Replace it with the following one:
```
{{ post.body|markdown }}
```
Then, in the `post/list.html` file, replace the following line:
```
{{ post.body|truncatewords:30|linebreaks }}
```
Then, swap it with the following one:
```
{ post.body|markdown|truncatewords_html:30 }}
```
The truncatewords_html filter truncates a string after a certain number of
words, avoiding unclosed HTML tags.


You can find more information about custom filters at *https://docs.djangoproject.com/en/2.0/howto/custom-template-tags/#writing-custom-template-filters*.

# Adding a sitemap to your site
The Django sitemap framework depends on `django.contrib.sites`, which allows you to associate objects to particular websites that are running with your project. This comes handy when you want to run multiple sites using a single Django project.

To install the sitemap framework, you will need to activate both the sites and the sitemap applications in our project. Edit the `settings.py` file of your project and add `django.contrib.sites` and `django.contrib.sitemaps` to the `INSTALLED_APPS` setting. Also, define a new setting for the site ID, as follows:
```py
SITE_ID = 1

INSTALLED_APPS = [
    # ...
    'django.contrib.sites',
    'django.contrib.sitemaps',
]
```

Now, run the following command to create the tables of the Django site application in the database:
```
python manage.py migrate
```

You should see an output that contains the following lines:
```
Operations to perform:
  Apply all migrations: admin, auth, blog, contenttypes, sessions, sites, taggit
Running migrations:
  Applying sites.0001_initial... OK
  Applying sites.0002_alter_domain_unique... OK
```

`blog/sitemaps.py`:
```py
from django.contrib.sitemaps import Sitemap

from .models import Post


class PostSitemap(Sitemap):
    changefreq = 'weekly'
    priority = 0.9

    def item(self):
        return Post.published.all()

    def lastmod(self, obj):
        return obj.updated
```

We create a custom sitemap by inheriting the `Sitemap` class of the `sitemaps` module. The `changefreq` and `priority` attributes indicate the change frequency of your post pages and their relevance in your website (the maximum value is 1).

The `items()` method returns the QuerySet of objects to include in this sitemap. By default, Django calls the `get_absolute_url()` method on each object to retrieve its URL. Remember that we created this method in [Chapter 1](https://github.com/keer2345/django-learning/blob/master/django-2-by-example/ch01.md) , Building a Blog Application, to retrieve the canonical URL for posts. If you want to specify the URL for each object, you can add a `location` method to your sitemap class.

The `lastmod` method receives each object returned by `items()` and returns the last time the object was modified. Both `changefreq` and `priority` methods can also be either methods or attributes.

You can take a look at the complete sitemap reference in the official Django documentation located at *https://docs.djangoproject.com/en/2.0/ref/contrib/sitemaps/*.

Finally, you will just need to add your sitemap URL. Edit the main `urls.py` file of your project and add the sitemap, as follows:
```py
from django.contrib import admin
from django.contrib.sitemaps.views import sitemap
from django.urls import include, path

from blog.sitemaps import PostSitemap

sitemaps = {
    'posts': PostSitemap,
}

urlpatterns = [
    path('admin/', admin.site.urls),
    path('blog/', include('blog.urls', namespace='blog')),
    path('sitemap.xml',
         sitemap, {'sitemaps': sitemaps},
         name='django.contrib.sitemaps.views.sitemap')
]
```

We defined a URL pattern that matches with `sitemap.xml` and uses the sitemap view. The `sitemaps` dictionary is passed to the `sitemap` view. Now, run the development server and open `http://127.0.0.1:8000/sitemap.xml` in your browser. You will note the following XML output:
```xml
<?xml version="1.0" encoding="utf-8"?>
    <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
    <url>
        <loc>http://example.com/blog/2017/12/15/markdown-post/</loc>
        <lastmod>2017-12-15</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.9</priority>
    </url>
    <url>
        <loc>
            http://example.com/blog/2017/12/14/who-was-django-reinhardt/
        </loc>
        <lastmod>2017-12-14</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.9</priority>
    </url>
</urlset>
```
